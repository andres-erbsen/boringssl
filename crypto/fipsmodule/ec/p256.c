/* Copyright (c) 2020, Google Inc.
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */

// An implementation of the NIST P-256 elliptic curve point multiplication.
// 256-bit Montgomery form for 64 and 32-bit. Field operations are generated by
// Fiat, which lives in //third_party/fiat.

#include <openssl/base.h>

#include <openssl/bn.h>
#include <openssl/ec.h>
#include <openssl/mem.h>

#include <assert.h>

#include "../../internal.h"
#include "../delocate.h"
#include "./internal.h"
#include "p256-internal.h"

#if defined(OPENSSL_64_BIT)
#if defined(BORINGSSL_HAS_UINT128)
#include "../../../third_party/fiat/p256_64.h"
#else
#include "../../../third_party/fiat/p256_64_msvc.h"
#endif
#elif defined(OPENSSL_32_BIT)
#include "../../../third_party/fiat/p256_32.h"
#else
#error "Must define either OPENSSL_32_BIT or OPENSSL_64_BIT"
#endif

// BEDROCK2 BUILDING BLOCKS

#if !defined(OPENSSL_NO_ASM) && defined(__GNUC__) && defined(__x86_64__)
void fiat_p256_adx_mul(uint64_t*, const uint64_t*, const uint64_t*);
void fiat_p256_adx_sqr(uint64_t*, const uint64_t*);
#elif !defined(OPENSSL_NO_ASM) && defined(__GNUC__) && defined(__aarch64__)
void ecp_nistz256_mul_mont(uint64_t x0[4],const uint64_t x1[4], const uint64_t x2[4]);
void ecp_nistz256_sqr_mont(uint64_t x0[4],const uint64_t x1[4]);
#endif

static void p256_coord_mul(fiat_p256_felem r, const fiat_p256_felem x, const fiat_p256_felem y) {
#if !defined(OPENSSL_NO_ASM) && defined(__GNUC__) && defined(__x86_64__)
  if (CRYPTO_is_BMI1_capable() && CRYPTO_is_BMI2_capable() &&
    CRYPTO_is_ADX_capable()) {
      return fiat_p256_adx_mul(out1, arg1, arg2);
  }
#elif !defined(OPENSSL_NO_ASM) && defined(__GNUC__) && defined(__aarch64__)
  return ecp_nistz256_mul_mont(r, x, y);
#endif
  return fiat_p256_mul(r, x, y);
}

static void p256_coord_sqr(fiat_p256_felem r, const fiat_p256_felem x) {
#if !defined(OPENSSL_NO_ASM) && defined(__GNUC__) && defined(__x86_64__)
  if (CRYPTO_is_BMI1_capable() && CRYPTO_is_BMI2_capable() &&
    CRYPTO_is_ADX_capable()) {
      fiat_p256_adx_sqr(out1, arg1);
      return;
  }
#elif !defined(OPENSSL_NO_ASM) && defined(__GNUC__) && defined(__aarch64__)
 return ecp_nistz256_sqr_mont(r, x);
#endif
  return fiat_p256_square(r, x);
}

static inline void fe_mul(uintptr_t out, uintptr_t x, uintptr_t y) {
	p256_coord_mul((crypto_word_t*)out, (crypto_word_t*)x, (crypto_word_t*)y);
}
static inline void fe_sqr(uintptr_t out, uintptr_t x) {
	p256_coord_sqr((crypto_word_t*)out, (crypto_word_t*)x);
}

static uintptr_t value_barrier(uintptr_t a) {
  return value_barrier_w(a);
}

static uintptr_t declassify(uintptr_t a) {
  return constant_time_declassify_w(a);
}

static inline uintptr_t nonzero(uintptr_t a) {
  return (intptr_t)(a|-a)>>(8*sizeof(a)-1);
}

static inline uintptr_t cmov(uintptr_t c, uintptr_t vnz, uintptr_t vz) {
#if defined(__clang__) && __clang_major__ == 16 && clang_minor__ == 0 && \
      defined(__x86_64__) || \
    defined(__clang__) && __clang_major__ == 19 && clang_minor__ == 1 && \
      defined(__aarch64__)
  return c ? vnz : vz; // generates cmov and keeps condition flag
#elif !defined(OPENSSL_NO_ASM) && defined(__GNUC__) && defined(__x86_64__)
  __asm__ (
      "testq %[c], %[c]\n"
      "cmovzq %[vz], %[vnz]"
      : [vnz] "+r"(vnz)
      : [vz] "r"(vz)
      , [c] "r"(c)
      : "cc");
  return vnz;
#elif !defined(OPENSSL_NO_ASM) && defined(__GNUC__) && defined(__i386__)
  __asm__ (
      "testl %[c], %[c]\n" // test%z[c] gives "invalid operand" on clang 16.0.6
      "cmovzl %[vz], %[vnz]"
      : [vnz] "+r"(vnz)
      : [vz] "r"(vz)
      , [c] "r"(c)
      : "cc");
  return vnz;
#endif
  uintptr_t m = value_barrier(nonzero(c));
  return (m&vnz) | (~m&vz);
}

#if defined(OPENSSL_64_BIT)
static uintptr_t adc64(uintptr_t carry_in, uintptr_t l, uintptr_t r, uintptr_t *low_out) {
  fiat_p256_uint1 carry_out;
  fiat_p256_addcarryx_u64(low_out, &carry_out, carry_in, l, r);
  return carry_out;
}
static uintptr_t sbb64(uintptr_t carry_in, uintptr_t l, uintptr_t r, uintptr_t *low_out) {
  fiat_p256_uint1 carry_out;
  fiat_p256_subborrowx_u64(low_out, &carry_out, carry_in, l, r);
  return carry_out;
}
static inline uintptr_t shrd(uintptr_t lo, uintptr_t hi, uintptr_t n) {
  return (((uint128_t)hi << 64) | (uint128_t)lo) >> (n&63);
}
#else
static inline uintptr_t shrd(uintptr_t lo, uintptr_t hi, uintptr_t n) {
  return (((uint64_t)hi << 32) | (uint64_t)lo) >> (n&31);
}
#endif

static void memcxor(uintptr_t d, uintptr_t s, uintptr_t n, uintptr_t mask) {
  constant_time_conditional_memxor((void*)d, (void*)s, n, mask);
}

#if 0
static void memcmov(uintptr_t d, uintptr_t s, uintptr_t n, uintptr_t mask) {
  constant_time_conditional_memcpy((void*)d, (void*)s, n, mask);
}
#endif

static void br2_memcpy(uintptr_t d, uintptr_t s, uintptr_t n) {
  OPENSSL_memcpy((void*)d, (void*)s, n);
}

static void br2_memset(uintptr_t d, uintptr_t v, uintptr_t n) {
  OPENSSL_memset((void*)d, v, n);
}

#if defined(OPENSSL_64_BIT)
static void fe_add(uintptr_t r, uintptr_t a, uintptr_t b) {
  uint64_t* out1 = (uint64_t*)r;
  const uint64_t* arg1 = (const uint64_t*)a;
  const uint64_t* arg2 = (const uint64_t*)b;
  uint64_t x1;
  fiat_p256_uint1 x2;
  uint64_t x3;
  fiat_p256_uint1 x4;
  uint64_t x5;
  fiat_p256_uint1 x6;
  uint64_t x7;
  fiat_p256_uint1 x8;
  uint64_t x9;
  fiat_p256_uint1 x10;
  uint64_t x11;
  fiat_p256_uint1 x12;
  uint64_t x13;
  fiat_p256_uint1 x14;
  uint64_t x15;
  fiat_p256_uint1 x16;
  uint64_t x17;
  fiat_p256_uint1 x18;
  uint64_t x19;
  uint64_t x20;
  uint64_t x21;
  uint64_t x22;
  fiat_p256_addcarryx_u64(&x1, &x2, 0x0, (arg1[0]), (arg2[0]));
  fiat_p256_addcarryx_u64(&x3, &x4, x2, (arg1[1]), (arg2[1]));
  fiat_p256_addcarryx_u64(&x5, &x6, x4, (arg1[2]), (arg2[2]));
  fiat_p256_addcarryx_u64(&x7, &x8, x6, (arg1[3]), (arg2[3]));
  fiat_p256_subborrowx_u64(&x9, &x10, 0x0, x1, UINT64_C(0xffffffffffffffff));
  fiat_p256_subborrowx_u64(&x11, &x12, x10, x3, UINT32_C(0xffffffff));
  fiat_p256_subborrowx_u64(&x13, &x14, x12, x5, 0x0);
  fiat_p256_subborrowx_u64(&x15, &x16, x14, x7, UINT64_C(0xffffffff00000001));
  fiat_p256_subborrowx_u64(&x17, &x18, x16, x8, 0x0);
  x19 = cmov(x18, x1, x9);
  x20 = cmov(x18, x3, x11);
  x21 = cmov(x18, x5, x13);
  x22 = cmov(x18, x7, x15);
  out1[0] = x19;
  out1[1] = x20;
  out1[2] = x21;
  out1[3] = x22;
}
#else
static void fe_add(uintptr_t r, uintptr_t a, uintptr_t b) {
  fiat_p256_add((void*)r, (void*)a, (void*)b);
}
#endif


#ifdef __GNUC__
typedef uint8_t  _br2_u8 __attribute__((aligned(1), may_alias));
typedef uint16_t _br2_u16 __attribute__((aligned(1), may_alias));
typedef uint32_t _br2_u32 __attribute__((aligned(1), may_alias));
typedef uint64_t _br2_u64 __attribute__((aligned(1), may_alias));
static inline  __attribute__((always_inline, unused))
uintptr_t _br2_load(uintptr_t a, uintptr_t sz) {
  switch (sz) {
  case 1: { return *(_br2_u8*)a; }
  case 2: { return *(_br2_u16*)a; }
  case 4: { return *(_br2_u32*)a; }
  case 8: { return *(_br2_u64*)a; }
  default: __builtin_unreachable();
  }
}
static inline __attribute__((always_inline, unused))
void _br2_store(uintptr_t a, uintptr_t v, uintptr_t sz) {
  switch (sz) {
  case 1: { *(_br2_u8*)a = v; return; }
  case 2: { *(_br2_u16*)a = v; return; }
  case 4: { *(_br2_u32*)a = v; return; }
  case 8: { *(_br2_u64*)a = v; return; }
  default: __builtin_unreachable();
  }
}
#else
// We use memcpy to work around -fstrict-aliasing.
// A plain memcpy is enough on clang 10, but not on gcc 10, which fails
// to infer the bounds on an integer loaded by memcpy.
// Adding a range mask after memcpy in turn makes slower code in clang.
// Loading individual bytes, shifting them together, and or-ing is fast
// on clang and sometimes on GCC, but other times GCC inlines individual
// byte operations without reconstructing wider accesses.
// The little-endian idiom below seems fast in gcc 9+ and clang 10.
static inline  __attribute__((always_inline, unused))
uintptr_t _br2_load(uintptr_t a, uintptr_t sz) {
  switch (sz) {
  case 1: { uint8_t  r = 0; memcpy(&r, (void*)a, 1); return r; }
  case 2: { uint16_t r = 0; memcpy(&r, (void*)a, 2); return r; }
  case 4: { uint32_t r = 0; memcpy(&r, (void*)a, 4); return r; }
  case 8: { uint64_t r = 0; memcpy(&r, (void*)a, 8); return r; }
  default: __builtin_unreachable();
  }
}
static inline __attribute__((always_inline, unused))
void _br2_store(uintptr_t a, uintptr_t v, uintptr_t sz) {
  memcpy((void*)a, &v, sz);
}
#endif


// BEDROCK2 GENERATED CODE

static inline __attribute__((always_inline, unused))
uintptr_t _br2_mulhuu(uintptr_t a, uintptr_t b) {
  #if (UINTPTR_MAX == (UINTMAX_C(1)<<31) - 1 + (UINTMAX_C(1)<<31))
	  return ((uint64_t)a * b) >> 32;
  #elif (UINTPTR_MAX == (UINTMAX_C(1)<<63) - 1 + (UINTMAX_C(1)<<63))
    return ((unsigned __int128)a * b) >> 64;
  #else
    #error ""32-bit or 64-bit uintptr_t required""
  #endif
}

static inline __attribute__((always_inline, unused))
uintptr_t _br2_divu(uintptr_t a, uintptr_t b) {
  if (!b) return -1;
  return a/b;
}

static inline __attribute__((always_inline, unused))
uintptr_t _br2_remu(uintptr_t a, uintptr_t b) {
  if (!b) return a;
  return a%b;
}

static inline __attribute__((always_inline, unused))
uintptr_t _br2_shamt(uintptr_t a) {
  return a&(sizeof(uintptr_t)*8-1);
}

static uintptr_t constant_time_msb(uintptr_t a) {
  uintptr_t m;
  m = (uintptr_t)((intptr_t)(a)>>_br2_shamt((uintptr_t)(UINTMAX_C(63))));
  return m;
}

static uintptr_t constant_time_is_zero(uintptr_t a) {
  uintptr_t z;
  z = constant_time_msb((((uintptr_t)(UINTMAX_C(-1)))^(a))&((a)-((uintptr_t)(UINTMAX_C(1)))));
  return z;
}

static uintptr_t fiat_p256_nz(uintptr_t x) {
  uintptr_t nz;
  nz = (((_br2_load(x, sizeof(uintptr_t)))|(_br2_load((x)+((uintptr_t)(UINTMAX_C(8))), sizeof(uintptr_t))))|(_br2_load((x)+((uintptr_t)(UINTMAX_C(16))), sizeof(uintptr_t))))|(_br2_load((x)+((uintptr_t)(UINTMAX_C(24))), sizeof(uintptr_t)));
  return nz;
}

static uintptr_t fiat_p256_is_zero(uintptr_t x) {
  uintptr_t z, nz;
  nz = fiat_p256_nz(x);
  z = constant_time_is_zero(nz);
  return z;
}

#if defined(OPENSSL_64_BIT)
static void fe_sub(uintptr_t out, uintptr_t x, uintptr_t y) {
  uintptr_t x2, x4, x6, x8, x1, x11, x3, x13, x5, x15, x7, x9, x17, x10, x12, x14, x16;
  x2 = sbb64((uintptr_t)(UINTMAX_C(0)), _br2_load(x, sizeof(uintptr_t)), _br2_load(y, sizeof(uintptr_t)), &x1);
  x4 = sbb64(x2, _br2_load((x)+((uintptr_t)(UINTMAX_C(8))), sizeof(uintptr_t)), _br2_load((y)+((uintptr_t)(UINTMAX_C(8))), sizeof(uintptr_t)), &x3);
  x6 = sbb64(x4, _br2_load((x)+((uintptr_t)(UINTMAX_C(16))), sizeof(uintptr_t)), _br2_load((y)+((uintptr_t)(UINTMAX_C(16))), sizeof(uintptr_t)), &x5);
  x8 = sbb64(x6, _br2_load((x)+((uintptr_t)(UINTMAX_C(24))), sizeof(uintptr_t)), _br2_load((y)+((uintptr_t)(UINTMAX_C(24))), sizeof(uintptr_t)), &x7);
  x9 = ((uintptr_t)(UINTMAX_C(0)))-(x8);
  x11 = adc64((uintptr_t)(UINTMAX_C(0)), x1, x9, &x10);
  x13 = adc64(x11, x3, (x9)&((uintptr_t)(UINTMAX_C(4294967295))), &x12);
  x15 = adc64(x13, x5, (uintptr_t)(UINTMAX_C(0)), &x14);
  x17 = adc64(x15, x7, (x9)&((uintptr_t)(UINTMAX_C(18446744069414584321))), &x16);
  x17 = (x17)+((uintptr_t)(UINTMAX_C(0)));
  _br2_store(out, x10, sizeof(uintptr_t));
  _br2_store((out)+((uintptr_t)(UINTMAX_C(8))), x12, sizeof(uintptr_t));
  _br2_store((out)+((uintptr_t)(UINTMAX_C(16))), x14, sizeof(uintptr_t));
  _br2_store((out)+((uintptr_t)(UINTMAX_C(24))), x16, sizeof(uintptr_t));
  return;
}
#else
static void fe_sub(uintptr_t r, uintptr_t a, uintptr_t b) {
  fiat_p256_sub((void*)r, (void*)a, (void*)b);
}
#endif

#if defined(OPENSSL_64_BIT)
static void fe_halve(uintptr_t y, uintptr_t x) {
  uintptr_t mh0, mh1, mh2, m, mh3, y0, y1, y2, y3, mmh;
  m = value_barrier(((uintptr_t)(UINTMAX_C(0)))-((_br2_load(x, sizeof(uintptr_t)))&((uintptr_t)(UINTMAX_C(1)))));
  mh0 = (uintptr_t)(UINTMAX_C(-1));
  mh1 = (mh0)>>_br2_shamt((uintptr_t)(UINTMAX_C(33)));
  mh2 = (mh0)<<_br2_shamt((uintptr_t)(UINTMAX_C(63)));
  mh3 = ((mh0)<<_br2_shamt((uintptr_t)(UINTMAX_C(32))))>>_br2_shamt((uintptr_t)(UINTMAX_C(1)));
  { uint8_t _br2_stackalloc_mmh[(uintptr_t)(UINTMAX_C(32))] = {0}; mmh = (uintptr_t)&_br2_stackalloc_mmh;
  _br2_store(mmh, (m)&(mh0), sizeof(uintptr_t));
  _br2_store((mmh)+((uintptr_t)(UINTMAX_C(8))), (m)&(mh1), sizeof(uintptr_t));
  _br2_store((mmh)+((uintptr_t)(UINTMAX_C(16))), (m)&(mh2), sizeof(uintptr_t));
  _br2_store((mmh)+((uintptr_t)(UINTMAX_C(24))), (m)&(mh3), sizeof(uintptr_t));
  y0 = _br2_load(y, sizeof(uintptr_t));
  y1 = _br2_load((y)+((uintptr_t)(UINTMAX_C(8))), sizeof(uintptr_t));
  y2 = _br2_load((y)+((uintptr_t)(UINTMAX_C(16))), sizeof(uintptr_t));
  y3 = _br2_load((y)+((uintptr_t)(UINTMAX_C(24))), sizeof(uintptr_t));
  y0 = shrd(y0, y1, (uintptr_t)(UINTMAX_C(1)));
  y1 = shrd(y1, y2, (uintptr_t)(UINTMAX_C(1)));
  y2 = shrd(y2, y3, (uintptr_t)(UINTMAX_C(1)));
  y3 = (y3)>>_br2_shamt((uintptr_t)(UINTMAX_C(1)));
  _br2_store(y, y0, sizeof(uintptr_t));
  _br2_store((y)+((uintptr_t)(UINTMAX_C(8))), y1, sizeof(uintptr_t));
  _br2_store((y)+((uintptr_t)(UINTMAX_C(16))), y2, sizeof(uintptr_t));
  _br2_store((y)+((uintptr_t)(UINTMAX_C(24))), y3, sizeof(uintptr_t));
  fe_sub(y, y, mmh);
  }
  return;
}
#else
static void fe_halve(uintptr_t y_, uintptr_t x_) {
  uint32_t *x = (uint32_t*) x_;
  uint32_t *y = (uint32_t*) y_;

  uint32_t m = value_barrier(-(x[0]&1));

  uint64_t mh[4];
  mh[0] = -1ULL;
  mh[1] = mh[0]>>33;
  mh[2] = mh[0]<<63;
  mh[3] = (mh[0]<<32)>>1;
  uint32_t mmh[8] = {0};

  constant_time_conditional_memcpy(&mmh, mh, sizeof(mmh), m);

  y[0] = shrd(x[0], y[1], 1);
  y[1] = shrd(x[1], y[2], 1);
  y[2] = shrd(x[2], y[3], 1);
  y[3] = shrd(x[3], y[4], 1);
  y[4] = shrd(x[4], y[5], 1);
  y[5] = shrd(x[5], y[6], 1);
  y[6] = shrd(x[6], y[7], 1);
  y[7] = x[7]>>1;
  fe_sub(y_, y_, (uintptr_t)&mmh[0]);
}
#endif

static uintptr_t p256_point_add_affine_nz_nz_neq(uintptr_t out, uintptr_t in1, uintptr_t in2) {
  uintptr_t z1z1, Hsqr, ok, different_x, different_y, u2, Hcub, r, h, s2;
  { uint8_t _br2_stackalloc_z1z1[(uintptr_t)(UINTMAX_C(32))] = {0}; z1z1 = (uintptr_t)&_br2_stackalloc_z1z1;
  { uint8_t _br2_stackalloc_u2[(uintptr_t)(UINTMAX_C(32))] = {0}; u2 = (uintptr_t)&_br2_stackalloc_u2;
  { uint8_t _br2_stackalloc_h[(uintptr_t)(UINTMAX_C(32))] = {0}; h = (uintptr_t)&_br2_stackalloc_h;
  { uint8_t _br2_stackalloc_s2[(uintptr_t)(UINTMAX_C(32))] = {0}; s2 = (uintptr_t)&_br2_stackalloc_s2;
  { uint8_t _br2_stackalloc_r[(uintptr_t)(UINTMAX_C(32))] = {0}; r = (uintptr_t)&_br2_stackalloc_r;
  { uint8_t _br2_stackalloc_Hsqr[(uintptr_t)(UINTMAX_C(32))] = {0}; Hsqr = (uintptr_t)&_br2_stackalloc_Hsqr;
  { uint8_t _br2_stackalloc_Hcub[(uintptr_t)(UINTMAX_C(32))] = {0}; Hcub = (uintptr_t)&_br2_stackalloc_Hcub;
  fe_sqr(z1z1, ((in1)+((uintptr_t)(UINTMAX_C(32))))+((uintptr_t)(UINTMAX_C(32))));
  fe_mul(u2, in2, z1z1);
  fe_sub(h, u2, in1);
  fe_mul(s2, ((in1)+((uintptr_t)(UINTMAX_C(32))))+((uintptr_t)(UINTMAX_C(32))), z1z1);
  fe_mul(((out)+((uintptr_t)(UINTMAX_C(32))))+((uintptr_t)(UINTMAX_C(32))), h, ((in1)+((uintptr_t)(UINTMAX_C(32))))+((uintptr_t)(UINTMAX_C(32))));
  fe_mul(s2, s2, (in2)+((uintptr_t)(UINTMAX_C(32))));
  fe_sub(r, s2, (in1)+((uintptr_t)(UINTMAX_C(32))));
  fe_sqr(Hsqr, h);
  fe_sqr(out, r);
  fe_mul(Hcub, Hsqr, h);
  fe_mul(u2, in1, Hsqr);
  different_x = fiat_p256_nz(Hcub);
  different_y = fiat_p256_nz(out);
  ok = value_barrier((different_x)|(different_y));
  fe_sub(out, out, Hcub);
  fe_sub(out, out, u2);
  fe_sub(out, out, u2);
  fe_sub(h, u2, out);
  fe_mul(s2, Hcub, (in1)+((uintptr_t)(UINTMAX_C(32))));
  fe_mul(h, h, r);
  fe_sub((out)+((uintptr_t)(UINTMAX_C(32))), h, s2);
  }
  }
  }
  }
  }
  }
  }
  return ok;
}

static uintptr_t p256_point_add_nz_nz_neq(uintptr_t out, uintptr_t in1, uintptr_t in2) {
  uintptr_t z1z1, z2z2, u1, Hsqr, ok, different_x, different_y, u2, Hcub, s1, r, h, s2;
  { uint8_t _br2_stackalloc_z1z1[(uintptr_t)(UINTMAX_C(32))] = {0}; z1z1 = (uintptr_t)&_br2_stackalloc_z1z1;
  { uint8_t _br2_stackalloc_z2z2[(uintptr_t)(UINTMAX_C(32))] = {0}; z2z2 = (uintptr_t)&_br2_stackalloc_z2z2;
  { uint8_t _br2_stackalloc_u1[(uintptr_t)(UINTMAX_C(32))] = {0}; u1 = (uintptr_t)&_br2_stackalloc_u1;
  { uint8_t _br2_stackalloc_u2[(uintptr_t)(UINTMAX_C(32))] = {0}; u2 = (uintptr_t)&_br2_stackalloc_u2;
  { uint8_t _br2_stackalloc_h[(uintptr_t)(UINTMAX_C(32))] = {0}; h = (uintptr_t)&_br2_stackalloc_h;
  { uint8_t _br2_stackalloc_s1[(uintptr_t)(UINTMAX_C(32))] = {0}; s1 = (uintptr_t)&_br2_stackalloc_s1;
  { uint8_t _br2_stackalloc_s2[(uintptr_t)(UINTMAX_C(32))] = {0}; s2 = (uintptr_t)&_br2_stackalloc_s2;
  { uint8_t _br2_stackalloc_r[(uintptr_t)(UINTMAX_C(32))] = {0}; r = (uintptr_t)&_br2_stackalloc_r;
  { uint8_t _br2_stackalloc_Hsqr[(uintptr_t)(UINTMAX_C(32))] = {0}; Hsqr = (uintptr_t)&_br2_stackalloc_Hsqr;
  { uint8_t _br2_stackalloc_Hcub[(uintptr_t)(UINTMAX_C(32))] = {0}; Hcub = (uintptr_t)&_br2_stackalloc_Hcub;
  fe_sqr(z1z1, ((in1)+((uintptr_t)(UINTMAX_C(32))))+((uintptr_t)(UINTMAX_C(32))));
  fe_mul(u2, in2, z1z1);
  fe_sqr(z2z2, ((in2)+((uintptr_t)(UINTMAX_C(32))))+((uintptr_t)(UINTMAX_C(32))));
  fe_mul(u1, in1, z2z2);
  fe_sub(h, u2, u1);
  fe_mul(s2, ((in1)+((uintptr_t)(UINTMAX_C(32))))+((uintptr_t)(UINTMAX_C(32))), z1z1);
  fe_mul(((out)+((uintptr_t)(UINTMAX_C(32))))+((uintptr_t)(UINTMAX_C(32))), h, ((in1)+((uintptr_t)(UINTMAX_C(32))))+((uintptr_t)(UINTMAX_C(32))));
  fe_mul(((out)+((uintptr_t)(UINTMAX_C(32))))+((uintptr_t)(UINTMAX_C(32))), ((out)+((uintptr_t)(UINTMAX_C(32))))+((uintptr_t)(UINTMAX_C(32))), ((in2)+((uintptr_t)(UINTMAX_C(32))))+((uintptr_t)(UINTMAX_C(32))));
  fe_mul(s2, s2, (in2)+((uintptr_t)(UINTMAX_C(32))));
  fe_mul(s1, ((in2)+((uintptr_t)(UINTMAX_C(32))))+((uintptr_t)(UINTMAX_C(32))), z2z2);
  fe_mul(s1, s1, (in1)+((uintptr_t)(UINTMAX_C(32))));
  fe_sub(r, s2, s1);
  fe_sqr(Hsqr, h);
  fe_sqr(out, r);
  fe_mul(Hcub, Hsqr, h);
  fe_mul(u2, u1, Hsqr);
  different_x = fiat_p256_nz(Hcub);
  different_y = fiat_p256_nz(out);
  ok = value_barrier((different_x)|(different_y));
  fe_sub(out, out, Hcub);
  fe_sub(out, out, u2);
  fe_sub(out, out, u2);
  fe_sub(h, u2, out);
  fe_mul(s2, Hcub, s1);
  fe_mul(h, h, r);
  fe_sub((out)+((uintptr_t)(UINTMAX_C(32))), h, s2);
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  return ok;
}

void p256_point_double(uintptr_t out, uintptr_t in1) {
  uintptr_t t2, tmp, A, D;
  { uint8_t _br2_stackalloc_D[(uintptr_t)(UINTMAX_C(32))] = {0}; D = (uintptr_t)&_br2_stackalloc_D;
  { uint8_t _br2_stackalloc_A[(uintptr_t)(UINTMAX_C(32))] = {0}; A = (uintptr_t)&_br2_stackalloc_A;
  { uint8_t _br2_stackalloc_tmp[(uintptr_t)(UINTMAX_C(32))] = {0}; tmp = (uintptr_t)&_br2_stackalloc_tmp;
  fe_add(D, (in1)+((uintptr_t)(UINTMAX_C(32))), (in1)+((uintptr_t)(UINTMAX_C(32))));
  fe_sqr(tmp, ((in1)+((uintptr_t)(UINTMAX_C(32))))+((uintptr_t)(UINTMAX_C(32))));
  fe_sqr(D, D);
  fe_mul(((out)+((uintptr_t)(UINTMAX_C(32))))+((uintptr_t)(UINTMAX_C(32))), ((in1)+((uintptr_t)(UINTMAX_C(32))))+((uintptr_t)(UINTMAX_C(32))), (in1)+((uintptr_t)(UINTMAX_C(32))));
  fe_add(((out)+((uintptr_t)(UINTMAX_C(32))))+((uintptr_t)(UINTMAX_C(32))), ((out)+((uintptr_t)(UINTMAX_C(32))))+((uintptr_t)(UINTMAX_C(32))), ((out)+((uintptr_t)(UINTMAX_C(32))))+((uintptr_t)(UINTMAX_C(32))));
  fe_add(A, in1, tmp);
  fe_sub(tmp, in1, tmp);
  { uint8_t _br2_stackalloc_t2[(uintptr_t)(UINTMAX_C(32))] = {0}; t2 = (uintptr_t)&_br2_stackalloc_t2;
  fe_add(t2, tmp, tmp);
  fe_add(tmp, t2, tmp);
  }
  fe_sqr((out)+((uintptr_t)(UINTMAX_C(32))), D);
  fe_mul(A, A, tmp);
  fe_mul(D, D, in1);
  fe_sqr(out, A);
  fe_add(tmp, D, D);
  fe_sub(out, out, tmp);
  fe_sub(D, D, out);
  fe_mul(D, D, A);
  fe_halve((out)+((uintptr_t)(UINTMAX_C(32))), (out)+((uintptr_t)(UINTMAX_C(32))));
  fe_sub((out)+((uintptr_t)(UINTMAX_C(32))), D, (out)+((uintptr_t)(UINTMAX_C(32))));
  }
  }
  }
  return;
}

// NOTE: in2 is a pointer to a *Jacobian* field element, denominator must be 1 in Montgomery form
void p256_point_add_affine_conditional(uintptr_t out, uintptr_t in1, uintptr_t in2, uintptr_t c) {
  uintptr_t p_out, p1zero, p2zero, ok, t;
  p1zero = fiat_p256_is_zero(((in1)+((uintptr_t)(UINTMAX_C(32))))+((uintptr_t)(UINTMAX_C(32))));
  p2zero = constant_time_is_zero_w(c);
  { uint8_t _br2_stackalloc_p_out[(uintptr_t)(UINTMAX_C(96))] = {0}; p_out = (uintptr_t)&_br2_stackalloc_p_out;
  ok = p256_point_add_affine_nz_nz_neq(p_out, in1, in2);
  ok = declassify(((p1zero)|(p2zero))|(ok));
  { uint8_t _br2_stackalloc_t[(uintptr_t)(UINTMAX_C(96))] = {0}; t = (uintptr_t)&_br2_stackalloc_t;
  br2_memset(t, (uintptr_t)(UINTMAX_C(0)), ((uintptr_t)(UINTMAX_C(3)))*((uintptr_t)(UINTMAX_C(32))));
  memcxor(t, p_out, ((uintptr_t)(UINTMAX_C(3)))*((uintptr_t)(UINTMAX_C(32))), (((uintptr_t)(UINTMAX_C(-1)))^(p1zero))&(((uintptr_t)(UINTMAX_C(-1)))^(p2zero)));
  memcxor(t, in1, ((uintptr_t)(UINTMAX_C(3)))*((uintptr_t)(UINTMAX_C(32))), (((uintptr_t)(UINTMAX_C(-1)))^(p1zero))&(p2zero));
  memcxor(t, in2, ((uintptr_t)(UINTMAX_C(3)))*((uintptr_t)(UINTMAX_C(32))), (p1zero)&(((uintptr_t)(UINTMAX_C(-1)))^(p2zero)));
  if (ok) {
    /*skip*/
  } else {
    p256_point_double(t, in1);
  }
  br2_memcpy(out, t, (uintptr_t)(UINTMAX_C(96)));
  }
  }
  return;
}

void p256_point_add(uintptr_t out, uintptr_t in1, uintptr_t in2) {
  uintptr_t p_out, p1zero, p2zero, ok, t;
  p1zero = fiat_p256_is_zero(((in1)+((uintptr_t)(UINTMAX_C(32))))+((uintptr_t)(UINTMAX_C(32))));
  p2zero = fiat_p256_is_zero(((in2)+((uintptr_t)(UINTMAX_C(32))))+((uintptr_t)(UINTMAX_C(32))));
  { uint8_t _br2_stackalloc_p_out[(uintptr_t)(UINTMAX_C(96))] = {0}; p_out = (uintptr_t)&_br2_stackalloc_p_out;
  ok = p256_point_add_nz_nz_neq(p_out, in1, in2);
  ok = declassify(((p1zero)|(p2zero))|(ok));
  { uint8_t _br2_stackalloc_t[(uintptr_t)(UINTMAX_C(96))] = {0}; t = (uintptr_t)&_br2_stackalloc_t;
  br2_memset(t, (uintptr_t)(UINTMAX_C(0)), ((uintptr_t)(UINTMAX_C(3)))*((uintptr_t)(UINTMAX_C(32))));
  memcxor(t, p_out, (uintptr_t)(UINTMAX_C(96)), (((uintptr_t)(UINTMAX_C(-1)))^(p1zero))&(((uintptr_t)(UINTMAX_C(-1)))^(p2zero)));
  memcxor(t, in1, (uintptr_t)(UINTMAX_C(96)), (((uintptr_t)(UINTMAX_C(-1)))^(p1zero))&(p2zero));
  memcxor(t, in2, (uintptr_t)(UINTMAX_C(96)), (p1zero)&(((uintptr_t)(UINTMAX_C(-1)))^(p2zero)));
  if (ok) {
    /*skip*/
  } else {
    p256_point_double(t, in1);
  }
  br2_memcpy(out, t, (uintptr_t)(UINTMAX_C(96)));
  }
  }
  return;
}


// POINT OPERATIONS


static void fiat_p256_opp_conditional(fiat_p256_felem x, crypto_word_t c) {
  fiat_p256_felem alignas(32) n;
  fiat_p256_opp(n, x);
  for (size_t i = 0; i < P256_LIMBS; ++i) {
    x[i] = cmov(c, n[i], x[i]);
  }
}

// bit returns the |i|th bit in |in|.
static crypto_word_t bit(const uint8_t *in, int i) {
  if (i < 0 || i >= 256) {
    return 0;
  }
  return (in[i >> 3] >> (i & 7)) & 1;
}

// point multiplication
static void fiat_p256_select_point_16(fiat_p256_felem dst_[3],
                                      const fiat_p256_felem src_[16][3],
                                      size_t i) {
  uint8_t *dst = (uint8_t*)dst_;
  const uint8_t *src = (uint8_t*)src_;
  static const size_t n = 16;
  static const size_t s = 96;
  uint8_t t[96] = {0};
#pragma clang loop unroll_count(4)
  for (size_t j = 0; j < n; j++) {
    constant_time_conditional_memxor(t, &src[j*s], s, constant_time_eq_w(i, j));
  }
  OPENSSL_memcpy(dst, t, s);
}

static void p256_point_mul(fiat_p256_felem out[3], const fiat_p256_felem p[3],
                           const uint8_t s[32]) {
  fiat_p256_felem alignas(32) p_pre_comp[16][3];
  OPENSSL_memcpy(p_pre_comp[0], p, sizeof(p_pre_comp[0]));
  for (size_t j = 2; j <= 16; ++j) {
    if (j & 1) {
      p256_point_add((uintptr_t)p_pre_comp[j-1], (uintptr_t)p_pre_comp[j-2], (uintptr_t)p_pre_comp[0]);
    } else {
      p256_point_double((uintptr_t)p_pre_comp[j-1], (uintptr_t)p_pre_comp[(j-1) / 2]);
    }
  }

  fiat_p256_felem alignas(32) ret[3];
  int ret_is_zero = 1;

  for (size_t i = 51; i < 52; i--) {
    if (!ret_is_zero) {
      for (size_t k = 4; k < 5; k--) {
        p256_point_double((uintptr_t)ret, (uintptr_t)ret);
      }
    }

    crypto_word_t bits = 0;
#pragma clang loop unroll(full)
    for (size_t k = 5; k < 6; k--) {
      bits |= bit(s, i*5-1 + k) << k;
    }
    crypto_word_t sign, digit;
    ec_GFp_nistp_recode_scalar_bits(&sign, &digit, bits);

    fiat_p256_felem alignas(32) t[3];
    fiat_p256_select_point_16(t, p_pre_comp, digit-1);
    fiat_p256_opp_conditional(t[1], sign);

    if (!ret_is_zero) {
      p256_point_add((uintptr_t)ret, (uintptr_t)ret, (uintptr_t)t);
    } else {
      OPENSSL_memcpy(ret, t, sizeof(ret));
      ret_is_zero = 0;
    }
  }

  OPENSSL_memcpy(out, ret, sizeof(ret));
}

// point_mul_public
#include "./p256_table.h"

static void fiat_p256_point_add_nz_nz_public(fiat_p256_felem out[3],
                                   const fiat_p256_felem in1[3],
                                   const fiat_p256_felem in2[3]) {
  fiat_p256_felem t[3];
  OPENSSL_memcpy(t, in1, sizeof(t));
  if (!p256_point_add_nz_nz_neq((uintptr_t)out, (uintptr_t)t, (uintptr_t)in2)) {
    p256_point_double((uintptr_t)out, (uintptr_t)in1);
  }
}

static void fiat_p256_point_add_affine_nz_nz_public(fiat_p256_felem out[3],
                                          const fiat_p256_felem in1[3],
                                          const fiat_p256_felem in2[2]) {
  fiat_p256_felem t[3];
  OPENSSL_memcpy(t, in1, sizeof(t));
  if (!p256_point_add_affine_nz_nz_neq((uintptr_t)out, (uintptr_t)t, (uintptr_t)in2)) {
    p256_point_double((uintptr_t)out, (uintptr_t)in1);
  }
}

static void ec_GFp_nistp256_point_mul_public(const EC_GROUP *group,
                                             EC_JACOBIAN *r,
                                             const EC_SCALAR *gs,
                                             const EC_JACOBIAN *p,
                                             const EC_SCALAR *ps) {
  const uint8_t* g_scalar = (uint8_t*)gs->words;
  int8_t p_wNAF[257] = {0};

  fiat_p256_felem alignas(32) p_pre_comp[1 << (4 - 1)][3];
  OPENSSL_memcpy(p_pre_comp[0][2], &p->Z, 32);
  if (!fiat_p256_is_zero((uintptr_t)p_pre_comp[0][2])) {
    ec_compute_wNAF(group, p_wNAF, ps, 256, 4);
    // Precompute multiples of |p|. p_pre_comp[i] is (2*i+1) * |p|.
    OPENSSL_memcpy(p_pre_comp[0][0], &p->X, 32);
    OPENSSL_memcpy(p_pre_comp[0][1], &p->Y, 32);
    fiat_p256_felem alignas(32) p2[3];
    p256_point_double((uintptr_t)p2, (uintptr_t)p_pre_comp[0]);
    for (size_t i = 1; i < OPENSSL_ARRAY_SIZE(p_pre_comp); i++) {
      p256_point_add_nz_nz_neq((uintptr_t)p_pre_comp[i], (uintptr_t)p_pre_comp[i - 1], (uintptr_t)p2);
    }
  }

  fiat_p256_felem alignas(32) ret[3];
  int ret_is_zero = 1;  // Save some point operations, avoid 0+Q
  for (int i = 256; i >= 0; i--) {
    if (!ret_is_zero) {
      p256_point_double((uintptr_t)ret, (uintptr_t)ret);
    }

    if (i <= 31) {
#pragma clang loop unroll(full)
      for (size_t j = 1; j<2; j--) {
        crypto_word_t bits = 0;
#pragma clang loop unroll(full)
        for (size_t k = 3; k<4; k--) {
          bits |= bit(g_scalar, i + j*32 + k*64) << k;
        }
        if (bits != 0) {
          if (!ret_is_zero) {
            fiat_p256_point_add_affine_nz_nz_public(ret, ret, fiat_p256_g_pre_comp[j][bits-1]);
	    ret_is_zero = fiat_p256_is_zero((uintptr_t)ret[2]);
          } else {
            OPENSSL_memcpy(ret, fiat_p256_g_pre_comp[j][bits-1], sizeof(fiat_p256_g_pre_comp[j][bits-1]));
	    fiat_p256_set_one(ret[2]);
            ret_is_zero = 0;
          }
        }
      }
    }

    int digit = p_wNAF[i];
    if (digit != 0) {
      assert(digit & 1);
      size_t idx = (size_t)(digit < 0 ? (-digit) >> 1 : digit >> 1);
      fiat_p256_felem t[3];
      OPENSSL_memcpy(t, p_pre_comp[idx], sizeof(t));
      if (digit < 0) {
        fiat_p256_opp(t[1], t[1]);
      }
      if (!ret_is_zero) {
        fiat_p256_point_add_nz_nz_public(ret, ret, t);
	ret_is_zero = fiat_p256_is_zero((uintptr_t)ret[2]);
      } else {
        OPENSSL_memcpy(ret, t, sizeof(ret));
        ret_is_zero = 0;
      }
    }
  }

  OPENSSL_memcpy(&r->X, ret[0], 32);
  OPENSSL_memcpy(&r->Y, ret[1], 32);
  OPENSSL_memcpy(&r->Z, ret[2], 32);
}

// p256_point_mul_base (small and full)

// fiat_p256_select_point_affine selects the |i|th point from a precomputation
// table and copies it to |dst|. If |n<=i|, the dstput is (0, 0).
static void fiat_p256_select_point_affine(
    fiat_p256_felem dst_[2], const fiat_p256_felem src_[/*n*/][2],
    size_t i, size_t n) {
  uint8_t *dst = (uint8_t*)dst_;
  const uint8_t *src = (uint8_t*)src_;
  static const size_t s = 64;
  uint8_t t[64] = {0};
#pragma clang loop unroll_count(8)
  for (size_t j = 0; j < n; j++) {
    constant_time_conditional_memxor(t, &src[j*s], s, constant_time_eq_w(i, j));
  }
  OPENSSL_memcpy(dst, t, s);
}

static void fiat_p256_conditional_zero_or_one(fiat_p256_felem x,
                                              crypto_word_t c) {
  fiat_p256_set_one(x);
  for (size_t i = 0; i < P256_LIMBS; ++i) {
    x[i] &= ~constant_time_is_zero_w(c);
  }
}

#if defined(OPENSSL_SMALL)

__attribute__((noinline))
static void fiat_p256_select_point_affine_15(
    fiat_p256_felem dst[2], const fiat_p256_felem src[/*n*/][2],
    size_t i) {
  fiat_p256_select_point_affine(dst, src, i, 15);
}

static void p256_point_mul_base(fiat_p256_felem ret[3], const uint8_t s[32]) {
  int ret_is_zero = 1;  // Save two point operations in the first round.
  fiat_p256_felem alignas(32) t[3];
  fiat_p256_set_one(t[2]);
  for (size_t i = 31; i < 32; i--) {
    if (!ret_is_zero) {
      p256_point_double((uintptr_t)ret, (uintptr_t)ret);
    }
#pragma clang loop unroll(full)
    for (size_t j = 1; j < 2; j--) {
      crypto_word_t bits = 0;
#pragma clang loop unroll(full)
      for (size_t k = 3; k < 4; k--) {
        bits |= bit(s, i + 32 * j + 64 * k) << k;
      }
      fiat_p256_select_point_affine_15(t, fiat_p256_g_pre_comp[j], bits-1);

      if (!ret_is_zero) {
        p256_point_add_affine_conditional((uintptr_t)ret, (uintptr_t)ret, (uintptr_t)t, (uintptr_t)bits);
      } else {
        OPENSSL_memcpy(ret, t, sizeof(t));
        fiat_p256_conditional_zero_or_one(ret[2], bits);
        ret_is_zero = 0;
      }
    }
  }
}

#else // defined(OPENSSL_SMALL)

// p256-nistz.c

/*
 * Copyright 2014-2016 The OpenSSL Project Authors. All Rights Reserved.
 * Copyright (c) 2014, Intel Corporation. All Rights Reserved.
 *
 * Licensed under the OpenSSL license (the "License").  You may not use
 * this file except in compliance with the License.  You can obtain a copy
 * in the file LICENSE in the source distribution or at
 * https://www.openssl.org/source/license.html
 *
 * Originally written by Shay Gueron (1, 2), and Vlad Krasnov (1)
 * (1) Intel Corporation, Israel Development Center, Haifa, Israel
 * (2) University of Haifa, Israel
 *
 * Reference:
 * S.Gueron and V.Krasnov, "Fast Prime Field Elliptic Curve Cryptography with
 *                          256 Bit Primes"
 */

// Precomputed tables for the default generator
typedef fiat_p256_felem _p256_affine_table_point[2];
typedef _p256_affine_table_point PRECOMP256_ROW[64];
#include "p256-nistz-table.h"

static void fiat_p256_select_point_affine_16(fiat_p256_felem dst[2],
                                             const fiat_p256_felem src[16][2],
                                             size_t i) {
  fiat_p256_select_point_affine(dst, src, i, 16);
}

static void fiat_p256_select_point_affine_64(fiat_p256_felem dst[2],
                                             const fiat_p256_felem src[64][2],
                                             size_t i) {
  fiat_p256_select_point_affine(dst, src, i, 64);
}

// See |ec_GFp_nistp_recode_scalar_bits| in util.c for details
static crypto_word_t booth_recode_w7(crypto_word_t in) {
  crypto_word_t s, d;
  s = ~((in >> 7) - 1);
  d = (1 << 8) - in - 1;
  d = (d & s) | (in & ~s);
  d = (d >> 1) + (d & 1);
  return (d << 1) + (s & 1);
}

static void p256_point_mul_base(fiat_p256_felem ret[3], const uint8_t s[32]) {
  int ret_is_zero = 1;
  alignas(32) fiat_p256_felem t[3];
  fiat_p256_set_one(t[2]);
  for (size_t i = 36; i < 37; i--) {
    crypto_word_t wvalue;
    if (!i) {
      wvalue = booth_recode_w7((s[0] << 1) & ((1<<(7+1))-1));
    } else {
      size_t bi = ((int)i*7 - 1) / 8;
      wvalue = (crypto_word_t)s[bi] | (bi < 31 ? s[bi + 1] : 0) << 8;
      wvalue = booth_recode_w7((wvalue >> (((int)i*7 - 1) % 8)) & ((1<<(7+1))-1));
    }
    if (i==36) {
      fiat_p256_select_point_affine_16(t, ecp_nistz256_precomputed[i], (wvalue>>1)-1);
    } else {
      fiat_p256_select_point_affine_64(t, ecp_nistz256_precomputed[i], (wvalue>>1)-1);
    }
    fiat_p256_opp_conditional(t[1], wvalue & 1);

    if (!ret_is_zero) {
      p256_point_add_affine_conditional((uintptr_t)ret, (uintptr_t)ret, (uintptr_t)t, wvalue>>1);
    } else {
      OPENSSL_memcpy(ret, t, sizeof(t));
      fiat_p256_conditional_zero_or_one(ret[2], wvalue >> 1);
      ret_is_zero = 0;
    }
  }
}

#endif // !OPENSSL_SMALL


// FIELD-ELEMENT INVERSION


// fiat_p256_inv_square calculates |out| = |in|^{-2}
//
// Based on Fermat's Little Theorem:
//   a^p = a (mod p)
//   a^{p-1} = 1 (mod p)
//   a^{p-3} = a^{-2} (mod p)
static void fiat_p256_inv_square(fiat_p256_felem out,
                                 const fiat_p256_felem in) {
  // This implements the addition chain described in
  // https://briansmith.org/ecc-inversion-addition-chains-01#p256_field_inversion
  fiat_p256_felem x2, x3, x6, x12, x15, x30, x32;
  p256_coord_sqr(x2, in);   // 2^2 - 2^1
  p256_coord_mul(x2, x2, in);  // 2^2 - 2^0

  p256_coord_sqr(x3, x2);   // 2^3 - 2^1
  p256_coord_mul(x3, x3, in);  // 2^3 - 2^0

  p256_coord_sqr(x6, x3);
  for (int i = 1; i < 3; i++) {
    p256_coord_sqr(x6, x6);
  }                           // 2^6 - 2^3
  p256_coord_mul(x6, x6, x3);  // 2^6 - 2^0

  p256_coord_sqr(x12, x6);
  for (int i = 1; i < 6; i++) {
    p256_coord_sqr(x12, x12);
  }                             // 2^12 - 2^6
  p256_coord_mul(x12, x12, x6);  // 2^12 - 2^0

  p256_coord_sqr(x15, x12);
  for (int i = 1; i < 3; i++) {
    p256_coord_sqr(x15, x15);
  }                             // 2^15 - 2^3
  p256_coord_mul(x15, x15, x3);  // 2^15 - 2^0

  p256_coord_sqr(x30, x15);
  for (int i = 1; i < 15; i++) {
    p256_coord_sqr(x30, x30);
  }                              // 2^30 - 2^15
  p256_coord_mul(x30, x30, x15);  // 2^30 - 2^0

  p256_coord_sqr(x32, x30);
  p256_coord_sqr(x32, x32);   // 2^32 - 2^2
  p256_coord_mul(x32, x32, x2);  // 2^32 - 2^0

  fiat_p256_felem ret;
  p256_coord_sqr(ret, x32);
  for (int i = 1; i < 31 + 1; i++) {
    p256_coord_sqr(ret, ret);
  }                             // 2^64 - 2^32
  p256_coord_mul(ret, ret, in);  // 2^64 - 2^32 + 2^0

  for (int i = 0; i < 96 + 32; i++) {
    p256_coord_sqr(ret, ret);
  }                              // 2^192 - 2^160 + 2^128
  p256_coord_mul(ret, ret, x32);  // 2^192 - 2^160 + 2^128 + 2^32 - 2^0

  for (int i = 0; i < 32; i++) {
    p256_coord_sqr(ret, ret);
  }                              // 2^224 - 2^192 + 2^160 + 2^64 - 2^32
  p256_coord_mul(ret, ret, x32);  // 2^224 - 2^192 + 2^160 + 2^64 - 2^0

  for (int i = 0; i < 30; i++) {
    p256_coord_sqr(ret, ret);
  }                              // 2^254 - 2^222 + 2^190 + 2^94 - 2^30
  p256_coord_mul(ret, ret, x30);  // 2^254 - 2^222 + 2^190 + 2^94 - 2^0

  p256_coord_sqr(ret, ret);
  p256_coord_sqr(out, ret);  // 2^256 - 2^224 + 2^192 + 2^96 - 2^2
}


// ARITHMETIC MODULO CURVE ORDER


#if !defined(OPENSSL_NO_ASM) && \
    (defined(OPENSSL_X86_64) || defined(OPENSSL_AARCH64))

static inline void nistz_p256ord_mul(BN_ULONG res[P256_LIMBS],
                               const BN_ULONG a[P256_LIMBS],
                               const BN_ULONG b[P256_LIMBS]) {
#if defined(OPENSSL_X86_64)
  if (CRYPTO_is_ADX_capable()) {
    return ecp_nistz256_ord_mul_montx(res, a, b);
  }
#endif
  return ecp_nistz256_ord_mul_mont(res, a, b);
}

static inline void nistz_p256ord_sqr(BN_ULONG res[P256_LIMBS],
                                     const BN_ULONG a[P256_LIMBS],
                                     BN_ULONG rep) {
#if defined(OPENSSL_X86_64)
  if (CRYPTO_is_ADX_capable()) {
    return ecp_nistz256_ord_sqr_montx(res, a, rep);
  }
#endif
  return ecp_nistz256_ord_sqr_mont(res, a, rep);
}

static void ecp_nistz256_inv0_mod_ord(const EC_GROUP *group, EC_SCALAR *out,
                                      const EC_SCALAR *in) {
  // table[i] stores a power of |in| corresponding to the matching enum value.
  enum {
    // The following indices specify the power in binary.
    i_1 = 0,
    i_10,
    i_11,
    i_101,
    i_111,
    i_1010,
    i_1111,
    i_10101,
    i_101010,
    i_101111,
    // The following indices specify 2^N-1, or N ones in a row.
    i_x6,
    i_x8,
    i_x16,
    i_x32
  };
  BN_ULONG table[15][P256_LIMBS];

  // https://briansmith.org/ecc-inversion-addition-chains-01#p256_scalar_inversion
  //
  // Even though this code path spares 12 squarings, 4.5%, and 13
  // multiplications, 25%, the overall sign operation is not that much faster,
  // not more that 2%. Most of the performance of this function comes from the
  // scalar operations.

  // Pre-calculate powers.
  OPENSSL_memcpy(table[i_1], in->words, P256_LIMBS * sizeof(BN_ULONG));

  nistz_p256ord_sqr(table[i_10], table[i_1], 1);

  nistz_p256ord_mul(table[i_11], table[i_1], table[i_10]);

  nistz_p256ord_mul(table[i_101], table[i_11], table[i_10]);

  nistz_p256ord_mul(table[i_111], table[i_101], table[i_10]);

  nistz_p256ord_sqr(table[i_1010], table[i_101], 1);

  nistz_p256ord_mul(table[i_1111], table[i_1010], table[i_101]);

  nistz_p256ord_sqr(table[i_10101], table[i_1010], 1);
  nistz_p256ord_mul(table[i_10101], table[i_10101], table[i_1]);

  nistz_p256ord_sqr(table[i_101010], table[i_10101], 1);

  nistz_p256ord_mul(table[i_101111], table[i_101010], table[i_101]);

  nistz_p256ord_mul(table[i_x6], table[i_101010], table[i_10101]);

  nistz_p256ord_sqr(table[i_x8], table[i_x6], 2);
  nistz_p256ord_mul(table[i_x8], table[i_x8], table[i_11]);

  nistz_p256ord_sqr(table[i_x16], table[i_x8], 8);
  nistz_p256ord_mul(table[i_x16], table[i_x16], table[i_x8]);

  nistz_p256ord_sqr(table[i_x32], table[i_x16], 16);
  nistz_p256ord_mul(table[i_x32], table[i_x32], table[i_x16]);

  // Compute |in| raised to the order-2.
  nistz_p256ord_sqr(out->words, table[i_x32], 64);
  nistz_p256ord_mul(out->words, out->words, table[i_x32]);
  static const struct {
    uint8_t p, i;
  } kChain[27] = {{32, i_x32},    {6, i_101111}, {5, i_111},    {4, i_11},
                  {5, i_1111},    {5, i_10101},  {4, i_101},    {3, i_101},
                  {3, i_101},     {5, i_111},    {9, i_101111}, {6, i_1111},
                  {2, i_1},       {5, i_1},      {6, i_1111},   {5, i_111},
                  {4, i_111},     {5, i_111},    {5, i_101},    {3, i_11},
                  {10, i_101111}, {2, i_11},     {5, i_11},     {5, i_11},
                  {3, i_1},       {7, i_10101},  {6, i_1111}};
  for (size_t i = 0; i < OPENSSL_ARRAY_SIZE(kChain); i++) {
    nistz_p256ord_sqr(out->words, out->words, kChain[i].p);
    nistz_p256ord_mul(out->words, out->words, table[kChain[i].i]);
  }
}

static int ecp_nistz256_scalar_to_montgomery_inv_vartime(const EC_GROUP *group,
                                                 EC_SCALAR *out,
                                                 const EC_SCALAR *in) {
#if defined(OPENSSL_X86_64)
  if (!CRYPTO_is_AVX_capable()) {
    // No AVX support; fallback to generic code.
    return ec_simple_scalar_to_montgomery_inv_vartime(group, out, in);
  }
#endif

  assert(group->order.N.width == P256_LIMBS);
  if (!beeu_mod_inverse_vartime(out->words, in->words, group->order.N.d)) {
    return 0;
  }

  // The result should be returned in the Montgomery domain.
  ec_scalar_to_montgomery(group, out, out);
  return 1;
}

#endif /* !defined(OPENSSL_NO_ASM) && \
          (defined(OPENSSL_X86_64) || defined(OPENSSL_AARCH64)) */


// OPENSSL EC_METHOD WRAPPERS


static void fiat_p256_from_generic(fiat_p256_felem out, const EC_FELEM *in) {
  OPENSSL_memcpy(out, in->words, 32);
}

static void fiat_p256_to_generic(EC_FELEM *out, const fiat_p256_felem in) {
  OPENSSL_memcpy(out->words, in, 32);
}

// Takes the Jacobian coordinates (X, Y, Z) of a point and returns (X', Y') =
// (X/Z^2, Y/Z^3).
static int ec_GFp_nistp256_point_get_affine_coordinates(
    const EC_GROUP *group, const EC_JACOBIAN *point, EC_FELEM *x_out,
    EC_FELEM *y_out) {
  if (constant_time_declassify_int(
          ec_GFp_simple_is_at_infinity(group, point))) {
    OPENSSL_PUT_ERROR(EC, EC_R_POINT_AT_INFINITY);
    return 0;
  }

  fiat_p256_felem z1, z2;
  fiat_p256_from_generic(z1, &point->Z);
  fiat_p256_inv_square(z2, z1);

  if (x_out != NULL) {
    fiat_p256_felem x;
    fiat_p256_from_generic(x, &point->X);
    p256_coord_mul(x, x, z2);
    fiat_p256_to_generic(x_out, x);
  }

  if (y_out != NULL) {
    fiat_p256_felem y;
    fiat_p256_from_generic(y, &point->Y);
    p256_coord_sqr(z2, z2);  // z^-4
    p256_coord_mul(y, y, z1);   // y * z
    p256_coord_mul(y, y, z2);   // y * z^-3
    fiat_p256_to_generic(y_out, y);
  }

  return 1;
}

static int ec_GFp_nistp256_cmp_x_coordinate(const EC_GROUP *group,
                                            const EC_JACOBIAN *p,
                                            const EC_SCALAR *r) {
  if (ec_GFp_simple_is_at_infinity(group, p)) {
    return 0;
  }

  // We wish to compare X/Z^2 with r. This is equivalent to comparing X with
  // r*Z^2. Note that X and Z are represented in Montgomery form, while r is
  // not.
  fiat_p256_felem Z2_mont;
  fiat_p256_from_generic(Z2_mont, &p->Z);
  p256_coord_mul(Z2_mont, Z2_mont, Z2_mont);

  fiat_p256_felem r_Z2;
  OPENSSL_memcpy(r_Z2, r->words, 32);  // r < order < p, so this is valid.
  p256_coord_mul(r_Z2, r_Z2, Z2_mont);

  fiat_p256_felem X;
  fiat_p256_from_generic(X, &p->X);
  fiat_p256_from_montgomery(X, X);

  if (OPENSSL_memcmp(&r_Z2, &X, sizeof(r_Z2)) == 0) {
    return 1;
  }

  // During signing the x coefficient is reduced modulo the group order.
  // Therefore there is a small possibility, less than 1/2^128, that group_order
  // < p.x < P. in that case we need not only to compare against |r| but also to
  // compare against r+group_order.
  assert(group->field.N.width == group->order.N.width);
  EC_FELEM tmp;
  BN_ULONG carry =
      bn_add_words(tmp.words, r->words, group->order.N.d, group->field.N.width);
  if (carry == 0 &&
      bn_less_than_words(tmp.words, group->field.N.d, group->field.N.width)) {
    fiat_p256_from_generic(r_Z2, &tmp);
    p256_coord_mul(r_Z2, r_Z2, Z2_mont);
    if (OPENSSL_memcmp(&r_Z2, &X, sizeof(r_Z2)) == 0) {
      return 1;
    }
  }

  return 0;
}

static void ec_GFp_nistp256_point_mul(const EC_GROUP *group, EC_JACOBIAN *r,
                                      const EC_JACOBIAN *p,
                                      const EC_SCALAR *scalar) {
  fiat_p256_felem t[3];
  fiat_p256_from_generic(t[0], &p->X);
  fiat_p256_from_generic(t[1], &p->Y);
  fiat_p256_from_generic(t[2], &p->Z);
  p256_point_mul(t, t, (uint8_t*)scalar->words);

  fiat_p256_to_generic(&r->X, t[0]);
  fiat_p256_to_generic(&r->Y, t[1]);
  fiat_p256_to_generic(&r->Z, t[2]);
}

static void ec_GFp_nistp256_point_mul_base(const EC_GROUP *group,
                                           EC_JACOBIAN *r, const EC_SCALAR *s) {
  fiat_p256_felem alignas(32) ret[3];
  p256_point_mul_base(ret, (uint8_t *)s->words);
  fiat_p256_to_generic(&r->X, ret[0]);
  fiat_p256_to_generic(&r->Y, ret[1]);
  fiat_p256_to_generic(&r->Z, ret[2]);
}

static void ec_GFp_nistp256_add(const EC_GROUP *group, EC_JACOBIAN *r,
                                const EC_JACOBIAN *a, const EC_JACOBIAN *b) {
  fiat_p256_felem p[3], q[3];
  fiat_p256_from_generic(p[0], &a->X);
  fiat_p256_from_generic(p[1], &a->Y);
  fiat_p256_from_generic(p[2], &a->Z);
  fiat_p256_from_generic(q[0], &b->X);
  fiat_p256_from_generic(q[1], &b->Y);
  fiat_p256_from_generic(q[2], &b->Z);
  p256_point_add((uintptr_t)p, (uintptr_t)p, (uintptr_t)q);
  fiat_p256_to_generic(&r->X, p[0]);
  fiat_p256_to_generic(&r->Y, p[1]);
  fiat_p256_to_generic(&r->Z, p[2]);
}

static void ec_GFp_nistp256_dbl(const EC_GROUP *group, EC_JACOBIAN *r,
                                const EC_JACOBIAN *a) {
  fiat_p256_felem p[3];
  fiat_p256_from_generic(p[0], &a->X);
  fiat_p256_from_generic(p[1], &a->Y);
  fiat_p256_from_generic(p[2], &a->Z);
  p256_point_double((uintptr_t)p, (uintptr_t)p);
  fiat_p256_to_generic(&r->X, p[0]);
  fiat_p256_to_generic(&r->Y, p[1]);
  fiat_p256_to_generic(&r->Z, p[2]);
}

DEFINE_METHOD_FUNCTION(EC_METHOD, EC_GFp_nistp256_method) {
  out->point_get_affine_coordinates =
      ec_GFp_nistp256_point_get_affine_coordinates;
  out->add = ec_GFp_nistp256_add;
  out->dbl = ec_GFp_nistp256_dbl;
  out->mul = ec_GFp_nistp256_point_mul;
  out->mul_base = ec_GFp_nistp256_point_mul_base;
  out->mul_public = ec_GFp_nistp256_point_mul_public;
  out->felem_mul = ec_GFp_mont_felem_mul;
  out->felem_sqr = ec_GFp_mont_felem_sqr;
  out->felem_to_bytes = ec_GFp_mont_felem_to_bytes;
  out->felem_from_bytes = ec_GFp_mont_felem_from_bytes;
  out->felem_reduce = ec_GFp_mont_felem_reduce;
  // TODO(davidben): This should use the specialized field arithmetic
  // implementation, rather than the generic one.
  out->felem_exp = ec_GFp_mont_felem_exp;
#if !defined(OPENSSL_NO_ASM) && \
    (defined(OPENSSL_X86_64) || defined(OPENSSL_AARCH64))
  out->scalar_inv0_montgomery = ecp_nistz256_inv0_mod_ord;
  out->scalar_to_montgomery_inv_vartime =
      ecp_nistz256_scalar_to_montgomery_inv_vartime;
#else
  out->scalar_inv0_montgomery = ec_simple_scalar_inv0_montgomery;
  out->scalar_to_montgomery_inv_vartime =
      ec_simple_scalar_to_montgomery_inv_vartime;
#endif
  out->cmp_x_coordinate = ec_GFp_nistp256_cmp_x_coordinate;
}
